## Prerequisites

* Basic Modular Arithmetic/Number Theory
* [RSA encryption/decryption](https://en.wikipedia.org/wiki/RSA_(cryptosystem))
* Basic understanding of computational complexity

## Problem Statement

I think i might leaked something but i dont know what

Author : Bebo07

Source files:
`chall2.py`
```py
import math
from Crypto.Util.number import *
from secret import flag,p,q
from gmpy2 import next_prime
m = bytes_to_long(flag.encode())
n=p*q


power1=getPrime(128)
power2=getPrime(128)
out1=pow((p+5*q),power1,n)
out2=pow((2*p-3*q),power2,n)
eq1 = next_prime(out1)

c = pow(m,eq1,n)


with open('chall2.txt', 'w') as f:
    f.write(f"power1={power1}\npower2={power2}\neq1={eq1}\nout2={out2}\nc={c}\nn={n}")
```

`chall2.txt`
```
power1=281633240040397659252345654576211057861
power2=176308336928924352184372543940536917109
hint=411
eq1=2215046782468309450936082777612424211412337114444319825829990136530150023421973276679233466961721799435832008176351257758211795258104410574651506816371525399470106295329892650116954910145110061394115128594706653901546850341101164907898346828022518433436756708015867100484886064022613201281974922516001003812543875124931017296069171534425347946706516721158931976668856772032986107756096884279339277577522744896393586820406756687660577611656150151320563864609280700993052969723348256651525099282363827609407754245152456057637748180188320357373038585979521690892103252278817084504770389439547939576161027195745675950581
out2=224716457567805571457452109314840584938194777933567695025383598737742953385932774494061722186466488058963292298731548262946252467708201178039920036687466838646578780171659412046424661511424885847858605733166167243266967519888832320006319574592040964724166606818031851868781293898640006645588451478651078888573257764059329308290191330600751437003945959195015039080555651110109402824088914942521092411739845889504681057496784722485112900862556479793984461508688747584333779913379205326096741063817431486115062002833764884691478125957020515087151797715139500054071639511693796733701302441791646733348130465995741750305
c=11590329449898382355259097288126297723330518724423158499663195432429148659629360772046004567610391586374248766268949395442626129829280485822846914892742999919200424494797999357420039284200041554727864577173539470903740570358887403929574729181050580051531054419822604967970652657582680503568450858145445133903843997167785099694035636639751563864456765279184903793606195210085887908261552418052046078949269345060242959548584449958223195825915868527413527818920779142424249900048576415289642381588131825356703220549540141172856377628272697983038659289548768939062762166728868090528927622873912001462022092096509127650036
n=14478207897963700838626231927254146456438092099321018357600633229947985294943471593095346392445363289100367665921624202726871181236619222731528254291046753377214521099844204178495251951493800962582981218384073953742392905995080971992691440003270383672514914405392107063745075388073134658615835329573872949946915357348899005066190003231102036536377065461296855755685790186655198033248021908662540544378202344400991059576331593290430353385561730605371820149402732270319368867098328023646016284500105286746932167888156663308664771634423721001257809156324013490651392177956201509967182496047787358208600006325742127976151
```

## Code Analysis

The `chall2.py` script retrieves secret numbers $p$ and $q$ and multiplies them to get $n=p\cdot q.$ It's safe to assume that $p,q$ are prime since $n$ is a ~2048-bit number and factordb can't factor it.

Our flag can be retrieved by finding $m,$ and we notice that $c\equiv m^{eq1}\pmod{n},$ so $c$ is the RSA-encrypted ciphertext of $m$ with public key $(eq1, n).$

`power1` and `power2` are public prime numbers, and $$out1\equiv (p+5q)^{power1}\pmod{n}$$ $$out2\equiv (2p+3q)^{power2}\pmod{n}.$$

Finally, `eq1` is simply the next probable prime number greater than `out1` (Source: https://gmpy2.readthedocs.io/en/latest/mpz.html#gmpy2.next_prime).

Of these values, we're given:
* The public primes `power1` and `power2`
* The ciphertext `c`
* The RSA public information `eq1` and `n`
* Some `hint=411` that we don't know how to use...

## Solution

Our goal here is to decrypt one RSA-encrypted message without any explicit knowledge of the private key $d.$ Of course, if we can find $p$ and $q$, we can simply compute $d\equiv [eq1]^{-1}\pmod{(p-1)(q-1)}.$ Let's use our two equations mod $n$ to do this! (of course, we only know the value of `out2` and not `out1`, but bear with me for now, we'll get back to this soon!)

Recall the [Binomial Theorem](https://en.wikipedia.org/wiki/Binomial_theorem): For any integer $m$ and real numbers $a,b,$ we have $$(a+b)^m=\sum_{k=0}^m\binom{m}{k}a^kb^{m-k},$$ where $\binom{m}{k}=\frac{m!}{k!(m-k)!}$

Applying the Binomial Theorem to our expression $(p+5q)^{power1}$ gives us $$(p+5q)^{power1}=\sum_{k=0}^{power1}\binom{power1}{k}p^kq^{power1-k}.$$ But since $p*q=n,$ when we take both sides mod $n$, the only terms that aren't necessarily divisible by $n$ occur when $k=0$ or $k=power1,$ so $$out1\equiv (p+5q)^{power1}\equiv p^{power1}+5^{power1}\cdot q^{power1}\pmod{n}.$$ By similar reasoning, $$out2\equiv 2^{power2}\cdot p^{power2} + 3^{power2}\cdot q^{power2}\pmod{n}.$$ We almost have a system of two linear equations, which we know how to solve easily, but the issue is that $p^{power1}\neq p^{power2}.$ Luckily, we can fix this issue by taking $out1^{power2}$ and $out2^{power1}$ and using the Binomial Theorem again! After doing this, we have $$out1^{power2}\equiv p^{power1\cdot power2}+5^{power1\cdot power2}\cdot q^{power1\cdot power2}\pmod{n}$$ and $$out2^{power1}\equiv 2^{power1\cdot power2}\cdot p^{power1\cdot power2} + 3^{power1\cdot power2}\cdot q^{power1\cdot power2}\pmod{n}.$$ This is a linear system of equations in $p^{power1\cdot power2},1^{power1\cdot power2},$ so eliminating $p^{power1\cdot power2}$ gives us $$(5^{power1\cdot power2} - 2^{-power1\cdot power2}\cdot 3^{power1\cdot power2})\cdot q^{power1\cdot power2}\equiv out1^{power2}-2^{-power1\cdot power2}\cdot out2^{power1}\pmod{n}.$$

(Important note: The only reason $2^{-power1\cdot power2}\pmod{n}$ exists is because $\gcd(2,n)=1$.)

This means that since we know `out2`, `n`, `power1`, and `power2`, assuming we can find `out1`, we can compute a multiple of $q$. Assuming this multiple of $q$ is not also a multiple of $n$ (which we can easily check), we can do $$q=\gcd(out1^{power2}-2^{-power1\cdot power2}\cdot out2^{power1}\mod{n}, n)$$ to compute $q$.

...But we don't know `out1`, we only know `eq1`, the smallest prime greater than `out1`. Well, how do we compute this next prime?

Usually, this is accomplished with a fast primality test: some quick algorithm that takes a number $m$ as input and returns "YES" if $m$ is prime and "NO" if $m$ is composite. Primality testing can be done quickly via algorithms like the [Miller-Rabin test.](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Miller%E2%80%93Rabin_test) (Note that this test is _probabilistic_, meaning that it only works _most_ of the time.)

How the `next_prime` function works is that it keeps checking `out1+1`, then `out1+2`, and so on until the prime test returns "YES." This is a _brute force algorithm_, which means that it checks if a potential solution is correct very quickly and runs this check on every possible input until a solution is found.

So how can we reverse this brute force algorithm? With a brute force algorithm of our own!

We can use `eq1-1` in place of `out1` to very quickly compute a potential value of `q` (gcd and powers mod $n$ are very fast to compute). If `q>1` and `q<N`, we know that our solution is correct. Otherwise, check `eq1-2`, then `eq1-3`, and so on until we eventually reach the original value of `out1`.

Once we have `q`, we find `p = n // q` (and we can check that `n == p*q` for our sanity) and compute `d = pow(eq1, -1, (p-1)*(q-1))` and finally `m = pow(c, d, n)`. Running `long_to_bytes(m)` gives us our flag.

Flag: 0xL4ugh{you_know_how_factor_N!}

Note: The `hint=411` from earlier actually tells us how many numbers we have to check until we reach the original value of `out1`!

`solve.py`
```py
from math import gcd

from Crypto.Util.number import long_to_bytes


def main():
    e1 = 281633240040397659252345654576211057861
    e2 = 176308336928924352184372543940536917109
    hint = 411
    eq1 = 2215046782468309450936082777612424211412337114444319825829990136530150023421973276679233466961721799435832008176351257758211795258104410574651506816371525399470106295329892650116954910145110061394115128594706653901546850341101164907898346828022518433436756708015867100484886064022613201281974922516001003812543875124931017296069171534425347946706516721158931976668856772032986107756096884279339277577522744896393586820406756687660577611656150151320563864609280700993052969723348256651525099282363827609407754245152456057637748180188320357373038585979521690892103252278817084504770389439547939576161027195745675950581
    c2 = 224716457567805571457452109314840584938194777933567695025383598737742953385932774494061722186466488058963292298731548262946252467708201178039920036687466838646578780171659412046424661511424885847858605733166167243266967519888832320006319574592040964724166606818031851868781293898640006645588451478651078888573257764059329308290191330600751437003945959195015039080555651110109402824088914942521092411739845889504681057496784722485112900862556479793984461508688747584333779913379205326096741063817431486115062002833764884691478125957020515087151797715139500054071639511693796733701302441791646733348130465995741750305
    c = 11590329449898382355259097288126297723330518724423158499663195432429148659629360772046004567610391586374248766268949395442626129829280485822846914892742999919200424494797999357420039284200041554727864577173539470903740570358887403929574729181050580051531054419822604967970652657582680503568450858145445133903843997167785099694035636639751563864456765279184903793606195210085887908261552418052046078949269345060242959548584449958223195825915868527413527818920779142424249900048576415289642381588131825356703220549540141172856377628272697983038659289548768939062762166728868090528927622873912001462022092096509127650036
    N = 14478207897963700838626231927254146456438092099321018357600633229947985294943471593095346392445363289100367665921624202726871181236619222731528254291046753377214521099844204178495251951493800962582981218384073953742392905995080971992691440003270383672514914405392107063745075388073134658615835329573872949946915357348899005066190003231102036536377065461296855755685790186655198033248021908662540544378202344400991059576331593290430353385561730605371820149402732270319368867098328023646016284500105286746932167888156663308664771634423721001257809156324013490651392177956201509967182496047787358208600006325742127976151

    a2 = 2

    q = 1
    c1 = eq1
    count = 0
    while q <= 1:
        q = gcd(pow(a2, (-e2 * e1), N) * pow(c2, e1, N) - pow(c1, e2, N), N)
        c1 -= 1
        count += 1

    p = N // q
    phi = (p-1)*(q-1)
    d = pow(eq1, -1, phi)
    flag = pow(c, d, N)
    print(long_to_bytes(flag))


if __name__ == "__main__":
    main()
```
